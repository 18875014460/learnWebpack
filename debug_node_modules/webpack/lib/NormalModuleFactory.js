/*
 MIT License http://www.opensource.org/licenses/mit-license.php
 Author Tobias Koppers @sokra
 */
"use strict";

const asyncLib = require("async");
const Tapable = require("tapable");
const NormalModule = require("./NormalModule");
const RawModule = require("./RawModule");
const Parser = require("./Parser");
const RuleSet = require("./RuleSet");

function loaderToIdent(data) {
	if(!data.options)
		return data.loader;
	if(typeof data.options === "string")
		return data.loader + "?" + data.options;
	if(typeof data.options !== "object")
		throw new Error("loader options must be string or object");
	if(data.ident)
		return data.loader + "??" + data.ident;
	return data.loader + "?" + JSON.stringify(data.options);
}

function identToLoaderRequest(resultString) {
	const idx = resultString.indexOf("?");
	let options;

	if(idx >= 0) {
		options = resultString.substr(idx + 1);
		resultString = resultString.substr(0, idx);

		return {
			loader: resultString,
			options
		};
	} else {
		return {
			loader: resultString
		};
	}
}

// module工厂，负责创建module
class NormalModuleFactory extends Tapable {
	constructor(context, resolvers, options) {
		super();
    this.resolvers = resolvers;
    // 根据 module.rules 选项 或者 module.loaders 选项创建ruleSet
    // https://webpack-v3.jsx.app/configuration/module/#module-rules
		this.ruleSet = new RuleSet(options.rules || options.loaders);
		this.cachePredicate = typeof options.unsafeCache === "function" ? options.unsafeCache : Boolean.bind(null, options.unsafeCache);
    this.context = context || "";
    // parser对象缓存
    this.parserCache = {};
    // 在自己身上注册factory事件handler
		this.plugin("factory", () => (result, callback) => {
      // 触发自己的resolver事件，
			let resolver = this.applyPluginsWaterfall0("resolver", null);

			// Ignored
			if(!resolver) return callback();

			resolver(result, (err, data) => {
				if(err) return callback(err);

				// Ignored
				if(!data) return callback();

				// direct module
				if(typeof data.source === "function")
					return callback(null, data);

        // 触发自己的after-resolve事件
				this.applyPluginsAsyncWaterfall("after-resolve", data, (err, result) => {
					if(err) return callback(err);

					// Ignored
					if(!result) return callback();
          // 触发自己的create-module事件
					let createdModule = this.applyPluginsBailResult("create-module", result);
					if(!createdModule) {

						if(!result.request) {
							return callback(new Error("Empty dependency (no request)"));
						}
            
            // modulefactory将必要的数据准备好后，创建module对象
						createdModule = new NormalModule(
							result.request,
							result.userRequest,
							result.rawRequest,
							result.loaders,
							result.resource,
							result.parser
						);
					}

					createdModule = this.applyPluginsWaterfall0("module", createdModule);

					return callback(null, createdModule);
				});
			});
    });
    // 在自己身上注册resolver事件handler
		this.plugin("resolver", () => (data, callback) => {
			const contextInfo = data.contextInfo;
			const context = data.context;
			const request = data.request;
      // NOTE: 识别当前module是否有 inline loader配置 https://webpack-v3.jsx.app/concepts/loaders/#inline
			const noAutoLoaders = /^-?!/.test(request);
			const noPrePostAutoLoaders = /^!!/.test(request);
			const noPostAutoLoaders = /^-!/.test(request);
      let elements = request.replace(/^-?!+/, "").replace(/!!+/g, "!").split("!");
      // 获取真实的module 路径
			let resource = elements.pop();
			elements = elements.map(identToLoaderRequest);

      // 并发运行两个函数后回调
			asyncLib.parallel([
				callback => this.resolveRequestArray(contextInfo, context, elements, this.resolvers.loader, callback),
				callback => {
					if(resource === "" || resource[0] === "?")
						return callback(null, {
							resource
						});

					this.resolvers.normal.resolve(contextInfo, context, resource, (err, resource, resourceResolveData) => {
						if(err) return callback(err);
						callback(null, {
							resourceResolveData,
							resource
						});
					});
				}
			], (err, results) => {
				if(err) return callback(err);
				let loaders = results[0];
				const resourceResolveData = results[1].resourceResolveData;
				resource = results[1].resource;

				// translate option idents
				try {
					loaders.forEach(item => {
            // https://webpack-v3.jsx.app/configuration/module/#rule-options-rule-query
						if(typeof item.options === "string" && /^\?/.test(item.options)) {
							const ident = item.options.substr(1);
							item.options = this.ruleSet.findOptionsByIdent(ident);
							item.ident = ident;
						}
					});
				} catch(e) {
					return callback(e);
				}

				if(resource === false) {
					// ignored
					return callback(null,
						new RawModule(
							"/* (ignored) */",
							`ignored ${context} ${request}`,
							`${request} (ignored)`
						)
					);
				}

				const userRequest = loaders.map(loaderToIdent).concat([resource]).join("!");

				let resourcePath = resource;
				let resourceQuery = "";
				const queryIndex = resourcePath.indexOf("?");
				if(queryIndex >= 0) {
					resourceQuery = resourcePath.substr(queryIndex);
					resourcePath = resourcePath.substr(0, queryIndex);
				}

				const result = this.ruleSet.exec({
					resource: resourcePath,
					resourceQuery,
					issuer: contextInfo.issuer,
					compiler: contextInfo.compiler
				});
        const settings = {};
        // NOTE: 解析记录当前module的loader
				const useLoadersPost = []; // post阶段loader
				const useLoaders = []; // 当前loader
				const useLoadersPre = []; // pre阶段loader
				result.forEach(r => {
					if(r.type === "use") {
            // https://webpack-v3.jsx.app/configuration/module/#rule-enforce
						if(r.enforce === "post" && !noPostAutoLoaders && !noPrePostAutoLoaders)
							useLoadersPost.push(r.value);
						else if(r.enforce === "pre" && !noPrePostAutoLoaders)
							useLoadersPre.push(r.value);
						else if(!r.enforce && !noAutoLoaders && !noPrePostAutoLoaders)
							useLoaders.push(r.value);
					} else {
						settings[r.type] = r.value;
					}
        });

				asyncLib.parallel([
					this.resolveRequestArray.bind(this, contextInfo, this.context, useLoadersPost, this.resolvers.loader),
					this.resolveRequestArray.bind(this, contextInfo, this.context, useLoaders, this.resolvers.loader),
					this.resolveRequestArray.bind(this, contextInfo, this.context, useLoadersPre, this.resolvers.loader)
				], (err, results) => {
          if(err) return callback(err);
          // NOTE: 准备好需要处理当前module的loaders对象
					loaders = results[0].concat(loaders, results[1], results[2]);
					process.nextTick(() => {
						callback(null, {
							context: context,
							request: loaders.map(loaderToIdent).concat([resource]).join("!"),
							dependencies: data.dependencies,
							userRequest,
							rawRequest: request,
							loaders,
							resource,
              resourceResolveData,
              // NOTE: 获取module对象需要的parser对象
							parser: this.getParser(settings.parser)
						});
					});
				});
			});
		});
	}

 /**
  * @description 根据传入的数据创建一个module对象
  * @param {*} data
  * @param {*} callback
  * @returns
  * @memberof NormalModuleFactory
  */
 create(data, callback) {
		const dependencies = data.dependencies;
    const cacheEntry = dependencies[0].__NormalModuleFactoryCache;
    // NOTE: 如果有构建过的module缓存，则直接返回
		if(cacheEntry) return callback(null, cacheEntry);
		const context = data.context || this.context;
		const request = dependencies[0].request;
    const contextInfo = data.contextInfo || {};
    // 触发自己身上的 before-resolve 事件
		this.applyPluginsAsyncWaterfall("before-resolve", {
			contextInfo,
      context,
      // 需要加载的文件的绝对路径
      request,
      // 文件的dep对象数据
			dependencies
		}, (err, result) => {
			if(err) return callback(err);

			// Ignored
			if(!result) return callback();

      // 触发自己的factory事件，事件handler在构造函数中注册。返回一个工厂函数
			const factory = this.applyPluginsWaterfall0("factory", null);

			// Ignored
			if(!factory) return callback();

			factory(result, (err, module) => {
				if(err) return callback(err);

				if(module && this.cachePredicate(module)) {
					dependencies.forEach(d => d.__NormalModuleFactoryCache = module);
				}
				callback(null, module);
			});
		});
	}

	resolveRequestArray(contextInfo, context, array, resolver, callback) {
		if(array.length === 0) return callback(null, []);
		asyncLib.map(array, (item, callback) => {
			resolver.resolve(contextInfo, context, item.loader, (err, result) => {
				if(err && /^[^/]*$/.test(item.loader) && !/-loader$/.test(item.loader)) {
					return resolver.resolve(contextInfo, context, item.loader + "-loader", err2 => {
						if(!err2) {
							err.message = err.message + "\n" +
								"BREAKING CHANGE: It's no longer allowed to omit the '-loader' suffix when using loaders.\n" +
								`                 You need to specify '${item.loader}-loader' instead of '${item.loader}',\n` +
								"                 see https://webpack.js.org/guides/migrating/#automatic-loader-module-name-extension-removed";
						}
						callback(err);
					});
				}
				if(err) return callback(err);

				const optionsOnly = item.options ? {
					options: item.options
				} : undefined;
				return callback(null, Object.assign({}, item, identToLoaderRequest(result), optionsOnly));
			});
		}, callback);
	}

	getParser(parserOptions) {
		let ident = "null";
		if(parserOptions) {
			if(parserOptions.ident)
				ident = parserOptions.ident;
			else
				ident = JSON.stringify(parserOptions);
		}
		const parser = this.parserCache[ident];
		if(parser)
			return parser;
		return this.parserCache[ident] = this.createParser(parserOptions);
	}

	createParser(parserOptions) {
		const parser = new Parser();
		this.applyPlugins2("parser", parser, parserOptions || {});
		return parser;
	}
}

module.exports = NormalModuleFactory;

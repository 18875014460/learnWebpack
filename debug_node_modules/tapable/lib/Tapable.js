// NOTE: 自行添加代码，引入外部log配置文件
const logConfig = require('../../../build/tapableLog.config');

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

// polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter
// using the polyfill specifically to avoid the call to `Object.defineProperty` for performance reasons
function fastFilter(fun/*, thisArg*/) {
	'use strict';

	if (this === void 0 || this === null) {
		throw new TypeError();
	}

	var t = Object(this);
	var len = t.length >>> 0;
	if (typeof fun !== 'function') {
		throw new TypeError();
	}

	var res = [];
	var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
	for (var i = 0; i < len; i++) {
		if (i in t) {
			var val = t[i];

			// NOTE: Technically this should Object.defineProperty at
			//       the next index, as push can be affected by
			//       properties on Object.prototype and Array.prototype.
			//       But that method's new, and collisions should be
			//       rare, so use the more-compatible alternative.
			if (fun.call(thisArg, val, i, t)) {
				res.push(val);
			}
		}
	}

	return res;
}

/**
 * @description Tapable构造函数。Tapable类提供了注册事件，以及触发事件的功能。
 * Compiler和Compilation类都是继承了Tapable来提供生命周期事件注册监听和触发功能的
 * NOTE: webpack4中对Tapable进行了重构，但是handler调用的思路还是类似的
 */
function Tapable() {
  // 私有属性_plugins用来保存注册进来的事件。下面是注册进来的test事件以及回调钩子的示例：
  /** 
   * this._plugins = {
   *   test: [handlerFun1, handlerFun2]
   *   ...
   * } 
   */  
	this._plugins = {};
}
module.exports = Tapable;

function copyProperties(from, to) {
	for(var key in from)
		to[key] = from[key];
	return to;
}

Tapable.mixin = function mixinTapable(pt) {
	copyProperties(Tapable.prototype, pt);
};

/**
 * NOTE: Tapable中定义applyPlugin**的方法簇，用来触发指定自定义事件，
 * 并且以不同的方式来调用注册监听的handlers（同步或异步的调用handler），
 * 影响了handlers的传入参数（主要是handler传入的第一个参数和最后一个参数，以及参数的数量）、
 * 实现方式（handler是否会接受一个next参数来显示调用下一个handler）
 * handlers链条的处理方式（handler能否中断下一个handler的调用）
 * 
 * NOTE:因为Tapable中有如此多的applyPlugin**方法来触发自定义事件，所以webpack的哪些生命周期事件由哪个具体的
 * applyPlugin** 方法触发，就变得额外关键，因为这个决定了插件在注册指定的webpack的生命周期事件handler时，
 * 要如何具体的实现这个handler
 * 在 https://webpack-v3.jsx.app/api/compiler/#event-hooks 中可以查到Compiler的每个具体的生命周期事件属于哪种
 * 类型，进而在实现响应的handler时，可以明确handler的参数传入和实现方式。
 * 
 * 同样的，在  https://webpack-v3.jsx.app/api/compilation/ 可以查看到compilation对象的所有生命周期
 */

/**
 * 触发指定事件，同步地按顺序地回调所有监听事件的handler，默认第一个参数是事件名。
 * 把事件名以外的参数传入到每一个回调钩子函数
 * @param {*} name 
 */
Tapable.prototype.applyPlugins = function applyPlugins(name) {
  if(!this._plugins[name]) return;
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
  // 取出除了第一个以外，剩下的参数（第一个参数是事件名）
	var args = Array.prototype.slice.call(arguments, 1);
	var plugins = this._plugins[name];
  for(var i = 0; i < plugins.length; i++) 
		plugins[i].apply(this, args);
};

/**
 * 触发指定事件，同步地按顺序地回调所有监听事件的handler，默认第一个参数是事件名
 * 不传入任何参数给回调钩子
 * NOTE: applyPlugins0中的0表示不会给handler传入任何参数（传入0个参数）,下面的applyPlugins*以此类推
 * @param {*} name 
 */
Tapable.prototype.applyPlugins0 = function applyPlugins0(name) {
	var plugins = this._plugins[name];
  if(!plugins) return;
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
  for(var i = 0; i < plugins.length; i++)
		plugins[i].call(this);
};

/**
 * 触发指定事件，同步地按顺序地回调所有handler，默认第一个参数是事件名
 * 第二个参数是传递给回调钩子的参数
 * @param {*} name 事件名
 * @param {*} param 传给回调钩子的参数
 */
Tapable.prototype.applyPlugins1 = function applyPlugins1(name, param) {
	var plugins = this._plugins[name];
  if(!plugins) return;
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
	for(var i = 0; i < plugins.length; i++)
	for(var i = 0; i < plugins.length; i++)
		plugins[i].call(this, param);
};

/**
 * 触发指定事件，同步地按顺序地回调所有事件钩子，默认第一个参数是事件名
 * 第二、三个参数是传递给回调钩子的参数
 * @param {*} name 
 * @param {*} param1 
 * @param {*} param2 
 */
Tapable.prototype.applyPlugins2 = function applyPlugins2(name, param1, param2) {
	var plugins = this._plugins[name];
  if(!plugins) return;
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
	for(var i = 0; i < plugins.length; i++)
		plugins[i].call(this, param1, param2);
};

/**
 * NOTE: 以下所有Waterfall**的函数都有以下特性
 * 1. 所有handler接收的第一个参数总是上一个handler处理的结果值.
 */

/**
 * 触发事件，同步地按顺序地回调所有事件钩子
 * 顾名思义，这个方法相当于是 瀑布式 调用，给第一个插件传入初始对象 init，然后经过第一个handler调用之后会获得一个结果对象，
 * 该结果对象会传给下一个handler 作为初始值，直到最后调用完毕，最后一个handler的直接结果传给 callback 作为初始值。
 * NOTE: 实际上类似于promise的链式调用处理，所有handler接收的第一个参数总是上一个handler处理的结果值，
 * handler的剩余参数则是调用applyPluginsWaterfall方法时传入的除去前两个参数的剩余参数
 * @param {*} name 
 * @param {*} init 传递给第一个handler的第一个参数
 */
Tapable.prototype.applyPluginsWaterfall = function applyPluginsWaterfall(name, init) {
  if(!this._plugins[name]) return init;
  // 得到除了name的参数数组
	var args = Array.prototype.slice.call(arguments, 1);
  var plugins = this._plugins[name];
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
  // init作为初始值传给第一个插件作为参数
	var current = init;
	for(var i = 0; i < plugins.length; i++) {
    args[0] = current;
    // 接收插件运行的结果作为下一个插件调用的参数
		current = plugins[i].apply(this, args);
	}
	return current;
};

/**
 * @description 触发指定事件，同步地按顺序地链式调用所有handler，
 * applyPluginsWaterfall0 中的0表示，每个handler除了接收上一个handler的结果值作为第一个参数外，额外接收0个参数
 * 下面的applyPluginsWaterfall* 以此类推
 */
Tapable.prototype.applyPluginsWaterfall0 = function applyPluginsWaterfall0(name, init) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
	var plugins = this._plugins[name];
	if(!plugins) return init;
	var current = init;
	for(var i = 0; i < plugins.length; i++)
		current = plugins[i].call(this, current);
	return current;
};

Tapable.prototype.applyPluginsWaterfall1 = function applyPluginsWaterfall1(name, init, param) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
	var plugins = this._plugins[name];
	if(!plugins) return init;
	var current = init;
	for(var i = 0; i < plugins.length; i++)
		current = plugins[i].call(this, current, param);
	return current;
};

Tapable.prototype.applyPluginsWaterfall2 = function applyPluginsWaterfall2(name, init, param1, param2) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
	var plugins = this._plugins[name];
	if(!plugins) return init;
	var current = init;
	for(var i = 0; i < plugins.length; i++)
		current = plugins[i].call(this, current, param1, param2);
	return current;
};

/**
 * Bail 保释，释放
 * @description 触发指定事件，同步的按顺序的调用所有handler，当遇到一个handler返回的result不为undefined时，
 * 停止调用剩余的handler
 */
Tapable.prototype.applyPluginsBailResult = function applyPluginsBailResult(name) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
	if(!this._plugins[name]) return;
	var args = Array.prototype.slice.call(arguments, 1);
	var plugins = this._plugins[name];
	for(var i = 0; i < plugins.length; i++) {
		var result = plugins[i].apply(this, args);
		if(typeof result !== "undefined") {
			return result;
		}
	}
};

/**
 * @description 与applyPluginsBailResult类似
 * applyPluginsBailResult1 中的1 意味着所有handler会接收一个applyPluginsBailResult1方法传入的参数
 * 下面的applyPluginsBailResult* 方法以此类推
 */
Tapable.prototype.applyPluginsBailResult1 = function applyPluginsBailResult1(name, param) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
	if(!this._plugins[name]) return;
	var plugins = this._plugins[name];
	for(var i = 0; i < plugins.length; i++) {
		var result = plugins[i].call(this, param);
		if(typeof result !== "undefined") {
			return result;
		}
	}
};

Tapable.prototype.applyPluginsBailResult2 = function applyPluginsBailResult2(name, param1, param2) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
	if(!this._plugins[name]) return;
	var plugins = this._plugins[name];
	for(var i = 0; i < plugins.length; i++) {
		var result = plugins[i].call(this, param1, param2);
		if(typeof result !== "undefined") {
			return result;
		}
	}
};

Tapable.prototype.applyPluginsBailResult3 = function applyPluginsBailResult3(name, param1, param2, param3) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
	if(!this._plugins[name]) return;
	var plugins = this._plugins[name];
	for(var i = 0; i < plugins.length; i++) {
		var result = plugins[i].call(this, param1, param2, param3);
		if(typeof result !== "undefined") {
			return result;
		}
	}
};

Tapable.prototype.applyPluginsBailResult4 = function applyPluginsBailResult4(name, param1, param2, param3, param4) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
  if(!this._plugins[name]) return;
	var plugins = this._plugins[name];
	for(var i = 0; i < plugins.length; i++) {
		var result = plugins[i].call(this, param1, param2, param3, param4);
		if(typeof result !== "undefined") {
			return result;
		}
	}
};

Tapable.prototype.applyPluginsBailResult5 = function applyPluginsBailResult5(name, param1, param2, param3, param4, param5) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
  if(!this._plugins[name]) return;
	var plugins = this._plugins[name];
	for(var i = 0; i < plugins.length; i++) {
		var result = plugins[i].call(this, param1, param2, param3, param4, param5);
		if(typeof result !== "undefined") {
			return result;
		}
	}
};

/**
 * NOTE: 以下所有Async** 的方法都有以下几个特性：
 * 1. 每个handler接收的最后一个参数都是next函数
 * 2. 每个handler只有显示调用了next函数才会触发下一个handler运行
 * 3. next函数的第一个参数位置代表了error，一旦传入一个真值，则意味着中断剩下handler的调用。
 * 4. handlers数组结束调用时，总会回调callback函数
 */

/**
 * @description 触发指定事件，顺序的回调注册好的handler。但是每个handler需要显式的回调next函数（每个handler的最后一个参数是next函数），
 * 来进行下一个handler的调用。否则下一个handler不会触发
 */
Tapable.prototype.applyPluginsAsyncSeries = Tapable.prototype.applyPluginsAsync = function applyPluginsAsyncSeries(name) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
  var args = Array.prototype.slice.call(arguments, 1);
  // 最后一个参数需要是一个callback
	var callback = args.pop();
	var plugins = this._plugins[name];
	if(!plugins || plugins.length === 0) return callback();
	var i = 0;
  var _this = this;
  
  // NOTE: 将next函数设置为最后一个参数，使得handler接收的最后一个参数总是next函数
	args.push(copyProperties(callback, function next(err) {
    // 当next被传入任何参数，则停止调用剩余的handler
		if(err) return callback(err);
		i++;
		if(i >= plugins.length) {
			return callback();
    }
    // 上一个handler调用next后，下一个handler才开始运行
		plugins[i].apply(_this, args);
	}));
	plugins[0].apply(this, args);
};

/**
 * @description 与applyPluginsAsyncSeries1类似
 * applyPluginsAsyncSeries1 中的1 表示 每个handler除了接收最后一个参数是next函数以外，
 * 还会接收1个applyPluginsAsyncSeries1传入的参数。
 * 下面的applyPluginsAsyncSeries*以此类推
 */
Tapable.prototype.applyPluginsAsyncSeries1 = function applyPluginsAsyncSeries1(name, param, callback) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
  var plugins = this._plugins[name];
	if(!plugins || plugins.length === 0) return callback();
	var i = 0;
	var _this = this;
	var innerCallback = copyProperties(callback, function next(err) {
		if(err) return callback(err);
		i++;
		if(i >= plugins.length) {
			return callback();
		}
		plugins[i].call(_this, param, innerCallback);
	});
	plugins[0].call(this, param, innerCallback);
};

/**
 * @description 与applyPluginsAsyncSeries类似，区别在于最后的callback函数可以接受最后一个handler调用next函数
 * 传入的所有参数作为参数
 */
Tapable.prototype.applyPluginsAsyncSeriesBailResult = function applyPluginsAsyncSeriesBailResult(name) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
  var args = Array.prototype.slice.call(arguments, 1);
	var callback = args.pop();
	if(!this._plugins[name] || this._plugins[name].length === 0) return callback();
	var plugins = this._plugins[name];
	var i = 0;
	var _this = this;
	args.push(copyProperties(callback, function next() {
		if(arguments.length > 0) return callback.apply(null, arguments);
		i++;
		if(i >= plugins.length) {
			return callback();
		}
		plugins[i].apply(_this, args);
	}));
	plugins[0].apply(this, args);
};

/**
 * @description 与applyPluginsAsyncSeriesBailResult类似
 * applyPluginsAsyncSeriesBailResult1中的1意味着，callback函数可以接受最后一个handler调用next函数时
 * 传入的一个参数作为参数
 */
Tapable.prototype.applyPluginsAsyncSeriesBailResult1 = function applyPluginsAsyncSeriesBailResult1(name, param, callback) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
  var plugins = this._plugins[name];
	if(!plugins || plugins.length === 0) return callback();
	var i = 0;
	var _this = this;
	var innerCallback = copyProperties(callback, function next(err, result) {
		if(arguments.length > 0) return callback(err, result);
		i++;
		if(i >= plugins.length) {
			return callback();
		}
		plugins[i].call(_this, param, innerCallback);
	});
	plugins[0].call(this, param, innerCallback);
};

/**
 * @description applyPluginsAsyncWaterfall具有Async 和 Waterfall两者的特性。其特点在于
 * 每个handler接受的next函数的第二个参数位置，可以传入一个当前handler的处理结果，作为下一个handler
 * 接受的参数
 */
Tapable.prototype.applyPluginsAsyncWaterfall = function applyPluginsAsyncWaterfall(name, init, callback) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
  if(!this._plugins[name] || this._plugins[name].length === 0) return callback(null, init);
	var plugins = this._plugins[name];
	var i = 0;
	var _this = this;
	var next = copyProperties(callback, function(err, value) {
		if(err) return callback(err);
		i++;
		if(i >= plugins.length) {
			return callback(null, value);
		}
		plugins[i].call(_this, value, next);
	});
	plugins[0].call(this, init, next);
};

/**
 * Parallel 并发的 并行的
 */

/**
 * @description 触发指定事件，同步的顺序的调用所有handler。所有handler接受的最后一个参数总是cb函数
 * 当handler运行出错时，可以显示调用cb函数并传入一个error对象（cb函数的调用必须是同步的），来中断剩下的handler调用。
 * applyPluginsParallel接受的最后一个参数总是callback，在所有handler结束调用时回调callback
 */
Tapable.prototype.applyPluginsParallel = function applyPluginsParallel(name) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);
  var args = Array.prototype.slice.call(arguments, 1);
  // 最后一个参数总是callback
	var callback = args.pop();
	if(!this._plugins[name] || this._plugins[name].length === 0) return callback();
	var plugins = this._plugins[name];
  var remaining = plugins.length;
  // 将最后一个参数设置为指定的cb函数，每个handler运行出错时可以通过显示调用cb函数并传入一个error对象
  // 来中断剩下的handler调用
	args.push(copyProperties(callback, function cb(err) {
		if(remaining < 0) return; // ignore
		if(err) {
      // 某个插件发生错误，回调传入err，在此将remaining设置为-1，
      // 所有插件都是同步的，都处于同一个task（microTask or macroTask），会中断掉下面for循环中后续插件的调用
			remaining = -1;
			return callback(err);
		}
		remaining--;
		if(remaining === 0) {
			return callback();
		}
	}));
	for(var i = 0; i < plugins.length; i++) {
    // 遍历运行所有的事件钩子
		plugins[i].apply(this, args);
		if(remaining < 0) return;
	}
};

Tapable.prototype.applyPluginsParallelBailResult = function applyPluginsParallelBailResult(name) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);

  var args = Array.prototype.slice.call(arguments, 1);
	var callback = args[args.length - 1];
	if(!this._plugins[name] || this._plugins[name].length === 0) return callback();
	var plugins = this._plugins[name];
	var currentPos = plugins.length;
	var currentResult;
	var done = [];
	for(var i = 0; i < plugins.length; i++) {
		args[args.length - 1] = (function(i) {
			return copyProperties(callback, function() {
				if(i >= currentPos) return; // ignore
				done.push(i);
				if(arguments.length > 0) {
					currentPos = i + 1;
					done = fastFilter.call(done, function(item) {
						return item <= i;
					});
					currentResult = Array.prototype.slice.call(arguments);
				}
				if(done.length === currentPos) {
					callback.apply(null, currentResult);
					currentPos = 0;
				}
			});
    }(i));
    // 按顺序调用所有插件，无法被打断
		plugins[i].apply(this, args);
	}
};

Tapable.prototype.applyPluginsParallelBailResult1 = function applyPluginsParallelBailResult1(name, param, callback) {
  // 打印事件触发
  this.logApply(arguments.callee.name, name);

  var plugins = this._plugins[name];
	if(!plugins || plugins.length === 0) return callback();
	var currentPos = plugins.length;
	var currentResult;
	var done = [];
	for(var i = 0; i < plugins.length; i++) {
		var innerCallback = (function(i) {
			return copyProperties(callback, function() {
				if(i >= currentPos) return; // ignore
				done.push(i);
				if(arguments.length > 0) {
					currentPos = i + 1;
					done = fastFilter.call(done, function(item) {
						return item <= i;
					});
					currentResult = Array.prototype.slice.call(arguments);
				}
				if(done.length === currentPos) {
					callback.apply(null, currentResult);
					currentPos = 0;
				}
			});
		}(i));
		plugins[i].call(this, param, innerCallback);
	}
};

/**
 * @description 测试指定生命周期事件是否有handler在监听
 */
Tapable.prototype.hasPlugins = function hasPlugins(name) {
	var plugins = this._plugins[name];
	return plugins && plugins.length > 0;
};

/**
 * @description 注册指定事件名，并提供回调钩子 类似于addEventListener
 * @param {string|stirng[]} name 事件名或者事件名数组
 * @param {function} fn 需要添加的回调钩子
 */
Tapable.prototype.plugin = function plugin(name, fn) {
	if(Array.isArray(name)) {
    // 如果是事件名数组，则向每一个事件名都添加回调钩子
		name.forEach(function(name) {
			this.plugin(name, fn);
		}, this);
		return;
  }
  // NOTE:打印当前注册事件
  this.logPlugin(name);
  // 向指定事件名添加回调钩子
	if(!this._plugins[name]) this._plugins[name] = [fn]; // 新建事件处理函数数组
	else this._plugins[name].push(fn);
};

/**
 * @description 传入插件实例，按参数顺序调用插件实例的apply方法，
 * 并传入当前Tapable实例
 * TODO: 需要把这个也打印出来，可以知道注册了哪些插件，并且插件是注册在哪个对象上
 */
Tapable.prototype.apply = function apply() {
  // NOTE: 自行添加，用于获取插件实例的名称
  var pluginNames = Array.prototype.slice.apply(arguments)
    .map(plugin => plugin.constructor.name);
  this.logPluginApply(pluginNames);

	for(var i = 0; i < arguments.length; i++) {
    // 调用传入的插件对象的apply方法
		arguments[i].apply(this);
	}
};

// NOTE: 自定义方法，用来打印插件注册
Tapable.prototype.logPluginApply = function (pluginNames) {
  if (logConfig.logPluginApplyEnable) {
    var className = this.constructor.name;
    console.log('插件注册: ' + className + ' applyPlugin: ' + pluginNames.join(', '));
  }
}

// NOTE: 自定义方法，用来打印 tapable实例的 事件触发
Tapable.prototype.logApply = function (funName, eventName) {
  if (logConfig.logApplyEnable) {
    var className = this.constructor.name;
    console.log('事件触发: ' + className + ' ' + funName + ': ' + eventName);
  }
}

// NOTE: 自定义方法，用来打印 tapable 实例的 事件注册
Tapable.prototype.logPlugin = function(eventName) {
 if (logConfig.logPluginEnable) {
    var className = this.constructor.name;
    console.log('事件注册: ' + className + ' plugin: ' + eventName);
 }
}

/** 
 * 打印结果如下：
 * Compiler plugin: before-run
Compiler plugin: this-compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: after-resolvers
Compiler plugin: compilation
Compiler plugin: entry-option
Compiler applyPluginsBailResult: entry-option
Compiler plugin: compilation
Compiler plugin: make
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: after-resolvers
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: after-emit
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: compilation
Compiler plugin: this-compilation
Compiler plugin: watch-run
Compiler plugin: run
Compiler plugin: after-compile
Compiler applyPlugins: after-resolvers
Compiler applyPluginsAsyncSeries: before-run
Compiler applyPluginsAsyncSeries: run
Compiler applyPluginsAsyncSeries: before-compile
Compiler applyPlugins: this-compilation
Compilation plugin: child-compiler
Compiler applyPlugins: compilation
Compilation plugin: normal-module-loader
Compilation plugin: normal-module-loader
Compilation plugin: optimize-chunks-basic
Compilation plugin: optimize-extracted-chunks-basic
Compilation plugin: optimize-chunks-basic
Compilation plugin: optimize-extracted-chunks-basic
Compilation plugin: optimize-chunks-basic
Compilation plugin: optimize-extracted-chunks-basic
Compilation plugin: optimize-chunks-basic
Compilation plugin: optimize-chunk-ids
Compilation plugin: optimize-module-order
Compilation plugin: optimize-chunk-order
Compilation plugin: finish-modules
Compilation plugin: optimize-modules-advanced
Compilation plugin: record-modules
Compilation plugin: revive-modules
Compilation plugin: record-chunks
Compilation plugin: revive-chunks
Compilation plugin: seal
Compiler applyPluginsParallel: make
Compilation applyPlugins: normal-module-loader
Compilation applyPlugins1: finish-modules
Compilation applyPlugins0: seal
Compilation applyPluginsBailResult1: optimize-modules-basic
Compilation applyPluginsBailResult1: optimize-modules
Compilation applyPluginsBailResult1: optimize-modules-advanced
Compilation applyPluginsBailResult1: optimize-chunks-basic
Compilation applyPluginsBailResult1: optimize-chunks
Compilation applyPluginsBailResult1: optimize-chunks-advanced
Compilation applyPluginsAsyncSeries: optimize-tree
Compilation applyPluginsBailResult: optimize-chunk-modules-basic
Compilation applyPluginsBailResult: optimize-chunk-modules
Compilation applyPluginsBailResult: optimize-chunk-modules-advanced
Compilation applyPluginsBailResult: should-record
Compilation applyPlugins2: revive-modules
Compilation applyPlugins1: optimize-module-order
Compilation applyPlugins2: revive-chunks
Compilation applyPlugins1: optimize-chunk-order
Compilation applyPlugins1: optimize-chunk-ids
Compilation applyPlugins2: record-modules
Compilation applyPlugins2: record-chunks
Compilation applyPluginsBailResult: should-generate-chunk-assets
Compilation applyPluginsAsyncSeries: additional-assets
Compilation applyPluginsAsyncSeries: optimize-chunk-assets
Compilation applyPluginsAsyncSeries: optimize-assets
Compilation applyPluginsBailResult: need-additional-seal
Compilation applyPluginsAsyncSeries: after-seal
Compiler applyPluginsAsyncSeries: after-compile
Compiler applyPluginsBailResult: should-emit
Compiler applyPluginsAsyncSeries: emit
Compiler applyPluginsAsyncSeries1: after-emit
Compilation applyPluginsBailResult: need-additional-pass
 */